---
title: "`r paste(params$sample_id, str_replace_all(params$report_name, '[\\._-]', ' '))`"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
  pdf_document:
    default
params:
  base_path: ''
  sample_id: ''
  sampletable: 'sample_table.txt'
  report_name: 'CNV-QC-report'
  out_format: 'html'
  configfile: 'config.yaml'
  workdir: ''
---

<style type="text/css">
.main-container {
  max-width: 100% !important;
  margin: auto;
}
[role=tab] {
  height: 40px;
  width: 250px;
}
</style>


```{r setup, include=FALSE}
#setwd(params$workdir)
library(plyranges)
library(tidyverse)
library(dendextend)
library(ggpubr)
library(scales)
library(RIdeogram)
library(DT)
library(yaml)
library(patchwork)
library(knitr)
library(kableExtra)
library(sessioninfo)
`%!in%` <- Negate(`%in%`)

get_script_dir <- function() {
	match <- commandArgs(trailingOnly = FALSE) %>%
		str_subset('--file=') %>%
		str_remove('--file=')
	check <- sys.frames()[[1]]$ofile
	if (length(match) > 0) {
        # Rscript
		return(normalizePath(match) %>% dirname())
	} else if (!is.null(check)) {
		# source'd via R console
        return(normalizePath(check) %>% dirname())
	} else {
		# likely testing in IDE
		return ('scripts')
	}
}
source(file.path(get_script_dir(), 'R_io_functions.R'))

report.setting <- function(...) {
  args <- list(...)
  #Check config for this specific report
  subconfig <- config$reports[[params$report_name]]
  for (arg in args) {
    subconfig <- subconfig[[arg]]
  }
  # Fall back to default
  if (is.null(subconfig)) {
    subconfig <- config$reports[['__default__']]
    for (arg in args) {
      subconfig <- subconfig[[arg]]
    }
  }
  # setting not found - error
  if (is.null(subconfig)) {
    quit(paste0('Tried to find non-existing config settings: reports$',
                params$report_name, "$", paste(args, collapse="$")))
  }
  #Convert to numeric if that makes sense
  if (!any(is.na(suppressWarnings(as.numeric(subconfig))))) {
    subconfig <- as.numeric(subconfig)
  }
  subconfig
}


include.section <- function(section) {
  include <- ifelse(all(report.setting('include_sections') == '__all__'), T, section %in% report.setting('include_sections'))
  exclude <- section %in% report.setting('exclude_sections')
  # also exclude QC sections if they are not defined in settings
  include <- include & !(str_detect(section, '^QC\\.(?!(summary|GenCall|settings))') & str_remove(section, 'QC\\.') %!in% cnv_tools)
  include & !exclude
}


# General variables & settings

image_folder <- paste0(params$report_name, '-', params$out_format, '_images/')

basepath <- params$base_path
workdir <- ifelse(params$workdir == '', getwd(), params$workdir)
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE,
                      fig.path = file.path(workdir, image_folder)
)
options(knitr.kable.NA = '')

config <- read_yaml(params$configfile)
datapath <- dirname(workdir)

cnv_tools <- config$settings$CNV.calling.tools

sampletable <- read_tsv(params$sampletable, col_types = 'cccccc', comment = "#")

sample_id <- params$sample_id
sex <- get_sample_info(sample_id, 'sex', sampletable)
ref_id <- get_sample_info(sample_id, 'ref_id', sampletable)
sex.ref <- get_sample_info(sample_id, 'sex.ref', sampletable)

#Sample_Name is an optional column in the sampletable
if ('Sample_Name' %in% colnames(sampletable)) {
  sample_name <- sampletable[sampletable$Sample_ID == sample_id, ]$Sample_Name
  ref_name <- ifelse(is.na(ref_id), NA, sampletable[sampletable$Sample_Name == ref_id, ]$Sample_Name)
} else {
  sample_name <- sample_id
  ref_name <- ifelse(is.na(ref_id), NA, ref_id)
}

if (!is.na(ref_id)) {
  sample_headers <- c(sample_name, paste0('Reference (', ref_name, ')'))
  names(sample_headers) <- c(sample_id, ref_id)
  use_ids <- c(sample_id, ref_id)
} else {
  sample_headers <- sample_name
  names(sample_headers) <- sample_id
  use_ids <- sample_id
}

#Reportable thresholds
reportable.loh <- report.setting('thresholds', 'reportable.loh')
reportable.cnv <- report.setting('thresholds', 'reportable.cnv')
critical.loh <- report.setting('thresholds', 'critical.loh')
critical.cnv <- report.setting('thresholds', 'critical.cnv')

#Warning tresholds
callrate_warnings <- report.setting('QCwarnings', 'callrate')
total_CNV_warnings <- report.setting('QCwarnings', 'total_CNV')
total_LOH_warnings <- report.setting('QCwarnings', 'total_LOH')
ratio_CNV_warnings <- report.setting('QCwarnings', 'loss_gain_ratio')
sizable_CNV_warnings <- report.setting('QCwarnings', 'sizable_CNV')
sizable_LOH_warnings <- report.setting('QCwarnings', 'sizable_LOH')
SNP_distance_reference <- report.setting('QCwarnings', 'SNP_distance_reference')

valid_name <- config$wildcard_constraints$sample_id
# valid_name <- ifelse(is.null(valid_name), '[0-9]{12}_R[0-9]{2}C[0-9]{2}', valid_name)
if (!all(str_detect(use_ids, valid_name))) {stop('Sample id does not match supplied or default wildcard constraints!')}

SNP.extra.ids <- c()
if (include.section('SNP.dendrogram')) {
  SNP.extra.ids <- get_SNP_clustering_IDs(report.setting('SNP_comparison', 'extra_samples'), sample_id, sampletable)
} 

gr_genes <- load_gtf_data(config)
gr_info  <- load_genomeInfo(config)

regions <- sampletable[sampletable$Sample_ID == sample_id, ]$Regions_of_Interest %>%
    str_split(';') %>% unlist()
include_roi_plots <-  include.section('regions.of.interest') & ifelse('Regions_of_Interest' %in% colnames(sampletable), !is.na(regions) & regions != '', FALSE)

## general functions

tr_tibble <- function(tb) {
  tr <- t(tb )
  colnames(tr) <- sample_headers[tr[1,]]
  tb <- as_tibble(tr, rownames = ' ')
  tb[2:nrow(tb),]
}


## Rmd related functions

simple_table_output <- function(tb, caption=NULL) {
  if (params$out_format == 'html') {
    return(datatable(tb, caption = caption,
                     options = list(dom = 't', pageLength = nrow(tb)), rownames = FALSE))
  } else {
    return(kable(tb, caption = caption))
  }
}

gene_table_output <- function(tb, caption = NULL, extra_cols = c()) {

  if (report.setting('call.data.and.plots', 'include.gene.table.details') == 'Call') {
    tb <- filter(tb, direct_hit)
    gene_area <- 'call'
  } else {
    extra_cols <- c(extra_cols, 'direct_hit')
    gene_area <- 'plot'
  }
  if (nrow(tb) == 0) {
    return(str_glue('No genes in the {gene_area} area.'))
  }
  tb <- tb %>%
    mutate(
      across(any_of(c('direct_hit', 'gene_type', 'strand')), ~ factor(.)),
      # high_impact should contain the Names of which lists were hit; TBD: sort by any(curated) > any(other) > none
      high_impact = ifelse(is.na(high_impact), '-', high_impact),
      highlight = ifelse(is.na(highlight), '-', highlight),
      #high_impact = factor(high_impact, levels = c(unique(na.omit(high_impact)), '-')),
      name_is_geneid = str_detect(gene_name, 'ENSG[0-9]{11}'),
      # REEV: gene_id *should* work, but won't if they are deprectated/not in Annonars
      REEV = str_glue("<a href='https://reev.bihealth.org/gene/{gene_name}' target='_blank' rel='noopener noreferrer'>{gene_name}</a>"),
      GTex = str_glue("<a href='https://gtexportal.org/home/gene/{gene_name}' target='_blank' rel='noopener noreferrer'>{gene_name}</a>"),
      NCBI = ifelse(name_is_geneid, '-', str_glue("<a href='https://pubmed.ncbi.nlm.nih.gov/?term={gene_name}' target='_blank' rel='noopener noreferrer'>{gene_name}</a>")),
      Ensembl = str_glue("<a href=' https://www.ensembl.org/Homo_sapiens/Gene/Summary?g={gene_id}' target='_blank' rel='noopener noreferrer'>{gene_id}</a>"),
    ) %>%
    arrange(desc(high_impact), desc(highlight), desc(direct_hit), start) %>%
    select(gene_name, gene_id, seqnames, start, end, high_impact, highlight, any_of(extra_cols), REEV, GTex, NCBI, Ensembl)
  if (params$out_format == 'html') {
    colors1 <- ifelse(tb$high_impact == '-', 'white', 'red')
    colors2 <- ifelse(tb$highlight == '-', 'white', 'orange')
    dt <- datatable(tb, rownames = FALSE, escape = FALSE,
                     options = list(dom = 'Bftilp', pageLength = 10,
                                    extensions = c('Buttons'),
                                    buttons = c('colvis', 'copy', 'csv', 'excel', 'print'),
                                    columnDefs = list(list(
                                      targets = 1:4, visible = FALSE
                                    ))
                     )) %>%
        formatStyle('high_impact', backgroundColor = styleRow(1:nrow(tb), colors1)) %>% # textAlign = 'center'
        formatStyle('highlight', backgroundColor = styleRow(1:nrow(tb), colors2))
    return(dt)
  } else {
    tb <- tb %>% select(gene_name, gene_id, high_impact, highlight, any_of(extra_cols))
    return(kable(tb, caption = caption))
  }
}

CNV_table_output <- function(tb, caption = NULL) {
  # Reorder & subset columns
    tb <- tb %>%
      select(sample_id, ID, Chr, Start, End, Size, reportable, CNV_type, CNV_caller,
             high_impact, highlight, reference_overlap,
             high_impact_genes, highlight_genes,
             copynumber, n_snp_probes,  n_premerged_calls, caller_confidence,
             tool.coverage.overlap, tool.overlap.state,
             reference_coverage, reference_caller )

  if (params$out_format == 'html') {
    dt <- datatable(tb,
            rownames = FALSE,
            extensions = c('Buttons', 'Scroller'),
            filter = 'top',
            caption = caption,
            options = list(
              scrollY = 300, scrollCollapse = TRUE, scrollX =  TRUE, scroller = TRUE,
              dom = 'Bftilp',
              buttons = c('colvis', 'copy', 'csv', 'excel', 'print'),
              columnDefs = list(
                #This uses 0-indexing vs the usual R 1-indexing
                list(targets = c(0,1,14:(ncol(tb)-1)), visible = FALSE)
              )
            )
          ) %>%
      formatRound(c('Start', 'End', 'Size'), digits = 0, mark = '.')
    return(dt)
  } else {
    tb <- tb %>% select(Chr, Start, End, Size, reportable, CNV_type, CNV_caller,
                        high_impact, highlight, reference_overlap,
                        high_impact_genes, highlight_genes
    )
    return(kable(tb, caption = caption))
  }


}


# Make a separate subchunnk, this is often needed when mixing loops, tabsets & html elements
subchunkify <- function(g, id, fig_height=7, fig_width=7, options = '') {
  g_deparsed <- paste0(deparse(function() {g}), collapse = '')

  sub_chunk <- paste0("```{r sub_chunk_", id, ", fig.height=", fig_height, ", fig.width=", fig_width, 
                      ifelse(options == '', options, paste(',', options)), ", echo=FALSE}\n",
  "(",  g_deparsed, ")()",
  "\n```")

  cat(knitr::knit(text = knitr::knit_expand(text = sub_chunk), quiet = TRUE))
}

```

```{r read.data}

# Read Data

## Raw (BAF / LRR), with column for applied filter
plot.probe.filter.setting <- ifelse(report.setting('call.data.and.plots', 'filter-settings') == '__default__',
                               config$settings$`default-filter-set`,
                               report.setting('call.data.and.plots', 'filter-settings'))

raw_LRR_BAF <- file.path(datapath, use_ids, paste0(use_ids, '.processed-data.tsv')) %>%
  lapply(read_raw) %>%
  bind_rows() %>%
  merge(lapply(file.path(datapath, use_ids, paste0(use_ids, '.filtered-data-', plot.probe.filter.setting, '.tsv')), read_raw) %>%
            lapply(function(x) mutate(x, filter.passed = TRUE) %>% dplyr::select(sample_id, Name, Chr, Position, filter.passed)) %>%
            bind_rows(),
        by = c('sample_id', 'Name', 'Chr', 'Position'), all.x = T
  ) %>%
  mutate(filter.passed = ifelse(is.na(filter.passed), F, filter.passed))

## RAW Genotype info
read_snps <- function(fname) {
    read_tsv(fname, col_select = c(1, 2, 11), show_col_types = FALSE) %>%
        rename_with(~ str_remove(., '^.*\\.gencall\\.'), c(3)) %>%
        mutate(GType = ifelse(GType == 'NC', NA, str_count(GType, 'A')),
               sample_id = basename(fname) %>% str_remove('\\.(processed|filtered)-data.*\\.tsv$'))
}

snp.ids <- unique(c(use_ids, SNP.extra.ids))
cluster.probe.filter.setting <- ifelse(report.setting('SNP_comparison', 'filter-settings') == '__default__',
                               config$settings$`default-filter-set`,
                               report.setting('SNP_comparison', 'filter-settings'))
# hclust will fail with <2 samples, so need to disable that section
if (length(snp.ids) < 2) {
  config$reports[[params$report_name]]$exclude_sections <- c(report.setting('exclude_sections'), 'SNP.dendrogram')
}

ignore.filter <- report.setting('SNP_comparison', 'ignore_filter')
snp_file_pattern <- ifelse(ignore.filter,
                           '.processed-data.tsv',
                           paste0('.filtered-data-', cluster.probe.filter.setting, '.tsv'))
# This is always needed (to get snp_dist_to_ref)
SNP.genotype.distances <- file.path(datapath, snp.ids, paste0(snp.ids, snp_file_pattern)) %>%
  lapply(read_snps) %>%
    bind_rows() %>%
    pivot_wider(names_from = sample_id, values_from = GType, values_fill = NA) %>%
    filter(if_all(everything(), ~!is.na(.))) %>%
    dplyr::select(-Index, -Name) %>%
    t() %>%
    dist(method = 'manhattan')


## CNV calls

cnv_calls <- lapply(file.path(datapath, use_ids, paste0(use_ids, '.combined-cnv-calls.tsv')),
                    load_preprocessed_cnvs) %>%
  bind_rows() %>%
  mutate(
      reportable = case_when(
        CNV_type %!in% c('gain', 'loss') & length >= reportable.loh & reference_overlap ~ 'yes, in ref.',
        CNV_type  %in% c('gain', 'loss') & length >= reportable.cnv & reference_overlap ~ 'yes, in ref.',
        CNV_type %!in% c('gain', 'loss') & length >= critical.loh                       ~ 'critical',
        CNV_type  %in% c('gain', 'loss') & length >= critical.cnv                       ~ 'critical',
        CNV_type %!in% c('gain', 'loss') & length >= reportable.loh                     ~ 'yes',
        CNV_type  %in% c('gain', 'loss') & length >= reportable.cnv                     ~ 'yes',
        reference_overlap                                                                ~ 'no, in ref.',
        TRUE                                                                             ~ 'no') %>%
            factor(levels = c('critical', 'yes', 'yes, in ref.', 'no', 'no, in ref.'))
    )

## GenCall logs
GenCall.stats <-  file.path(datapath, use_ids, paste0(use_ids, '.stats.txt')) %>%
    lapply(read_tsv, show_col_types = FALSE, col_types = cols(computed_gender = col_character(),
                                                              sentrix_barcode = col_character())) %>%
    bind_rows() %>%
    dplyr::select(-(5:7)) %>%
    mutate(gtc = str_remove(gtc, '.gencall.gtc')) %>%
    dplyr::rename(sample_id = gtc)

```


# Sample Overview


```{r sample.information, eval = include.section('sample.information'), results = 'asis'}

cat('## Sample Information\n\n')

info.tb <- sampletable %>%
  filter(Sample_ID %in% c(sample_id, ref_id)) %>%
  dplyr::select(Sample_ID, Sex, Reference_Sample,
                any_of(report.setting('sample.info.extra.cols'))) %>%
  mutate(`Analysis run date` = Sys.Date()) %>%
  tr_tibble() %>%
  dplyr::select(-starts_with('Reference ('))

simple_table_output(info.tb)

cat('\n\n')

```

## QC metrics {.tabset}

```{r qc.metrics}

metrics <- list(
    GenCall.stats %>%
        dplyr::select(sample_id, call_rate, computed_gender) %>%
        mutate(call_rate = round(call_rate, 3)),
    raw_LRR_BAF %>%
        group_by(sample_id) %>%
        summarise(SNPs_post_filter = (100 * sum(filter.passed, na.rm=T) / unique(GenCall.stats$number_snps) ) %>%
                                                                        format(digits = 2, nsmall=2) %>% paste('%')),
    tibble(sample_id = use_ids,
           SNP.distance.to.ref = unlist(ifelse(is.na(ref_id), list('-'), list(c(SNP.genotype.distances[1], '-'))))
    ),
    cnv_calls %>%
        #don't do individual tools here -> move to per CNV_caller section!
        filter(tool.overlap.state != 'pre-overlap') %>%
        group_by(sample_id) %>%
        mutate(class = factor(ifelse(CNV_type %!in% c('gain', 'loss'), 'LOH', 'CNV'), levels = c('CNV', 'LOH')),
               loss.gain_log2ratio = log2(sum(CNV_type == 'gain') / sum(CNV_type == 'loss')) %>% round(digits = 2),
               loss.gain_log2ratio = ifelse(is.infinite(loss.gain_log2ratio) | is.nan(loss.gain_log2ratio), NA, loss.gain_log2ratio)
        ) %>%
        group_by(sample_id, loss.gain_log2ratio, class, .drop = F) %>%
        summarise(total_calls = n(),
                  reportable_new_calls = sum(str_detect(reportable, 'critical|yes$')),
                  critical_new_calls = sum(reportable == 'critical'),
                  ) %>%
        pivot_wider(names_from = class, values_from = contains('calls'))
)

# Datatable takes colors differently than ggplot, doesn't work somehow
green_col <- ifelse(params$out_format == 'html', 'rgb(146,208,80)', 'green') #rgb(146,208,80) // lightgreen

apply_gr_th <- function(data, warning_levels){
    case_when(
        data > warning_levels[[2]] ~ 'orange',
        data > warning_levels[[1]] ~ 'yellow',
        TRUE                       ~ green_col,
    )
}

metric.colors <- list(
    mutate(metrics[[1]],
                 call_rate = case_when(
                    call_rate < callrate_warnings[[2]]  ~ 'red',
                    call_rate < callrate_warnings[[1]]  ~ 'yellow',
                    TRUE ~ green_col),
                 computed_gender = ifelse(tolower(computed_gender) != sex, 'red', green_col)),
    mutate(metrics[[2]],
                 SNPs_post_filter = 'white'),
    mutate(metrics[[3]],
                 SNP.distance.to.ref = ifelse(SNP.distance.to.ref == '-', 'white',
                                              apply_gr_th(SNP.distance.to.ref, SNP_distance_reference))),
    mutate(metrics[[4]],
                 loss.gain_log2ratio = apply_gr_th(abs(loss.gain_log2ratio), ratio_CNV_warnings),
                 total_calls_CNV = apply_gr_th(total_calls_CNV, total_CNV_warnings),
                 total_calls_LOH = apply_gr_th(total_calls_LOH, total_LOH_warnings),
                 reportable_new_calls_CNV = apply_gr_th(reportable_new_calls_CNV, sizable_CNV_warnings),
                 reportable_new_calls_LOH = apply_gr_th(reportable_new_calls_LOH, sizable_LOH_warnings),
                 critical_new_calls_CNV = ifelse(critical_new_calls_CNV >= 1, 'red', green_col),
                 critical_new_calls_LOH = ifelse(critical_new_calls_LOH >= 1, 'red', green_col),
                )
        )

Combined.metrics <- purrr::reduce(metrics, full_join, by = 'sample_id') %>% tr_tibble()
Combined.colors <-  purrr::reduce(metric.colors, full_join, by = 'sample_id') %>% tr_tibble()

get_call_stats_tool <- function(use.tool) {
    cnv_calls %>%
        filter(tool.overlap.state != 'combined' & use.tool %in% CNV_caller) %>%
        group_by(sample_id) %>%
        mutate(loss.gain_log2ratio = log2(sum(CNV_type == 'gain') / sum(CNV_type == 'loss')) %>% round(digits = 2),
               loss.gain_log2ratio = ifelse(is.infinite(loss.gain_log2ratio) | is.nan(loss.gain_log2ratio), NA, loss.gain_log2ratio)
        ) %>%
        group_by(sample_id, CNV_type, loss.gain_log2ratio) %>%
        summarise(total_calls = n(),
                  reportable_new_calls = sum(str_detect(reportable, 'critical|yes$')),
                  critical_new_calls = sum(reportable == 'critical')
        ) %>%
        pivot_wider(names_from = CNV_type, values_from = contains('calls')) %>%
        tr_tibble()
}

export.tb <- full_join(
        purrr::reduce(metrics, full_join, by = 'sample_id') %>%
            mutate(across(.cols = everything(), ~as.character(.)))  %>%
        pivot_longer(-sample_id, names_to = 'Measure', values_to = 'Value'),
        purrr::reduce(metric.colors, full_join, by = 'sample_id') %>%
            mutate(across(-sample_id, ~str_replace(., 'white', 'NA') %>%
                                    str_replace(green_col, 'OK') %>%
                                    str_replace('yellow', 'unusual') %>%
                                    str_replace('orange', 'warning') %>%
                                    str_replace('red', 'critical'))) %>%
        pivot_longer(-sample_id, names_to = 'Measure', values_to = 'Check'),
        by = c('sample_id', 'Measure')
        ) %>%
        filter(sample_id == !!sample_id)

write_tsv(export.tb, file.path(workdir, str_glue('{sample_id}.summary-check.tsv')))

```


```{r qc.summary, eval = include.section('QC.summary'), results='asis'}
cat('### Summary\n\n')
if (params$out_format == 'html') {
    datatable(Combined.metrics, options = list(dom = 't', pageLength = nrow(Combined.metrics)),
              rownames = FALSE) %>%
        formatStyle(2, backgroundColor = styleRow(1:nrow(Combined.metrics), unlist(Combined.colors[, sample_headers[[1]]])), textAlign = 'center') %>%
        # DT can take specification of non-existing columns - just need a workaround for the sample_header call
        formatStyle(3, backgroundColor = styleRow(1:nrow(Combined.metrics), unlist(Combined.colors[, sample_headers[[length(sample_headers)]]])), textAlign = 'center')
} else {

  tbout <- kable(Combined.metrics, align = c('l', rep('c', length(sample_headers))), format = 'latex') %>%
    column_spec(2, background = unlist(Combined.colors[, sample_headers[[1]]]))
  if (!is.na(ref_id)) {
     tbout <- column_spec(tbout, 3, background = unlist(Combined.colors[, sample_headers[[2]]]))
  }
  tbout
}

cat('\n\n')
```




```{r qc.gencall, eval = include.section('QC.GenCall'), results='asis'}
cat('### GenCall\n\n')
simple_table_output(GenCall.stats %>% tr_tibble())
cat('\n\n')
```

```{r qc.penncnv, eval = include.section('QC.PennCNV'), results='asis'}
cat('### PennCNV\n\n')
# Extract qc summary stats from PennCNV log files
logpath <- ifelse(fs::is_absolute_path(config$log_path),
                 config$log_path,
                 file.path(basepath, config$log_path))
logfiles <- list.files(file.path(logpath, 'PennCNV', sample_id),
                       pattern = '(auto|chrx|chry).error.log', full.names = T)

penncnv.stats <- lapply(logfiles, function(fname) {
    chrs <- basename(fname) %>% str_extract('^[^\\.]+')
    lines <- readLines(fname)
    # Extract from summary line
    tb <- lines %>%
      str_subset('NOTICE: quality summary') %>%
            str_remove('.*: ') %>%
            str_split(' ') %>%
            unlist() %>%
            as_tibble_col(column_name = 'dummy') %>%
            separate(dummy, c('Name', 'value'), sep = '=') %>%
            filter(Name %!in% c('WF', 'GCWF')) %>%
            mutate(Name = str_remove(Name, '[XY]'))
    # Get wave correction
    tb <- bind_rows(tb, lines %>%
            str_subset('Adjusting LRR by GC model') %>%
            str_remove('.*: ') %>%
            str_split(', ') %>%
            unlist() %>%
            as_tibble_col(column_name = 'dummy') %>%
            separate(dummy, c('Name', 'value'), sep = ' changes from ') %>%
            mutate(Name = paste(Name, '(adjusted)'))
    )
    # Get median correction BAF & LRR (auto only)
    if (chrs == 'auto') {
        tb[str_detect(tb$Name, 'median' ),] <- lines %>%
                str_subset('Median-adjusting') %>%
                str_replace('.*(LRR|BAF).*( -?[0-9]\\.[0-9]{4})', '\\1_median;0-adjusted by\\2') %>%
                as_tibble() %>%
                separate(value, c('Name', 'value'), sep = ';')
    }

    mutate(tb, chr = ifelse(chrs == 'auto', 'chr1:22', chrs))
    }) %>%
    bind_rows() %>%
    pivot_wider(names_from = chr, values_from = value) %>%
    dplyr::rename(` ` = Name)

simple_table_output(penncnv.stats)

# Number of CNVs, LOHs called at which thresholds
tbout <- get_call_stats_tool('PennCNV')
simple_table_output(tbout)
cat('\n\n')
```
```{r qc.CBS, eval = include.section('QC.CBS'), results='asis'}
cat('### CBS\n\n')
tbout <- get_call_stats_tool('CBS')
simple_table_output(tbout)
cat('\n\n')
```

```{r sessioninfo, eval = include.section('QC.settings'), results='asis'}
cat('### Pipeline settings\n\n')
# ```yaml
# `r xfun::file_string(params$configfile)`
# ```

#Unclear if this will work in pdf?
cat(knitr::knit(text = knitr::knit_expand(text = '```yaml\n`r xfun::file_string(params$configfile)`\n```'), quiet = TRUE))
cat('\n\n')
session_info()
cat('\n\n')
```


# CNV calling

```{r CNV.call.functions}

get_cnv_y <- function(CNV_type, CNV_caller) {
    # Go by tool order (start from 1)
    out <- match(CNV_caller, cnv_tools)
    # For PennCNV LOH & gain/loss may overlap and need separate tracks
    out <- ifelse(CNV_type %!in% c('gain', 'loss'), 1-out, out)
    out
}

format_size <- function(size) {
  oom_f <- ifelse(size >= 1e6, 1e6, 1e3)
  num <- round(size / oom_f)
  paste0(num, ifelse(oom_f == 1e3, 'kb', 'Mb'))
}

make_LRR_BAF_plots <- function(call.row,
                               total_min_size = 2e6, flank_factor = 2) {

  chr <- call.row$Chr
  start <- call.row$Start
  end <- call.row$End
  size <- call.row$Size

  if (total_min_size < 1e4) {
    warning(str_glue('Re-Setting Minimum size window around primary plot area (CNV/region: {chr}:{start}-{end}) to at least 10kb'))
    total_min_size <- 1e4
  }

  # Set initial plot window as Call size * (1+2*flank_factor)
  win_start <- start - size * flank_factor
  win_end <- end + size * flank_factor
  # If it is below minimum increase accordingly
  if (win_end - win_start < total_min_size) {
    #Don't want .5 positions
    win_start <- win_start - floor((total_min_size - win_end + win_start)/2)
    win_end <- win_end + ceiling((total_min_size - win_end + win_start)/2)
  }

  #Shrink down ends if they overlap 0/Chr_Max (from what is covered by probes)
  chr_max <- raw_LRR_BAF %>% filter(Chr == chr) %>% pull(Position) %>% max()
  win_start <- max(win_start, 0)
  win_end <- min(win_end, chr_max)

  # get raw LRR & BAF data; mark filtered points
  plot.data <- raw_LRR_BAF %>%
    filter(Chr == chr & Position >= win_start & Position <= win_end) %>%
    mutate(Sample_Name = factor(sapply(sample_id, function(x) sample_headers[x]), levels = sample_headers))

  if (nrow(plot.data)==0){
    warn_msg <- str_glue('No SNP probes found in primary plot area: {chr}:{start}-{end} +- {round(size/1e3)}kb')
    warning(warn_msg)
    return(list('gg' = warn_msg, 'calls' = tibble(), 'genes' = tibble()))
  }

  calls <- cnv_calls %>%
    filter(tool.overlap.state != 'combined' & seqnames == chr & end >= win_start & start < win_end) %>%
    mutate(x_pos = (end + start) / 2,
           y_pos = map2_int(CNV_type, CNV_caller, get_cnv_y),
           color = ifelse(CNV_type %!in% c('gain', 'loss'), 'grey50', '#1a9850'),
           color = ifelse(CNV_type == 'loss', '#f46d43', color),
           Sample_Name = factor(sapply(sample_id, function(x) sample_headers[x]), levels = sample_headers)
           ) %>%
    # Need to ensure table contains reference so everything is properly facet_wrapped
    bind_rows(tibble(Sample_Name = factor(sample_headers, levels = sample_headers),
                     x_pos = NA_integer_, y_pos = NA_integer_))

  direct_genes <- gr_genes %>%
    filter_by_overlaps(GRanges(seqnames = chr, strand = '*', ranges = IRanges(start = start, end = end))) %>%
    as_tibble()

  high_impact_list <- call.row$high_impact_genes %>% str_split(',') %>% unlist()
  highlight_list <- call.row$highlight_genes %>% str_split(',') %>% unlist()
  gene.data <- gr_genes %>%
    filter_by_overlaps(GRanges(seqnames = chr, strand = '*', ranges = IRanges(start = win_start, end = win_end))) %>%
    as_tibble() %>%
    mutate(x_pos = (end + start) / 2,
           y_pos = ifelse(strand == '+', 1, 0),
           Sample_Name = paste(sample_headers, collapse = '---'),
           direct_hit = gene_id %in% direct_genes$gene_id,
           high_impact = ifelse(gene_name %in% high_impact_list,
                                paste(unlist(call.row$high.impact), collapse = ';'), NA_character_),
           highlight = ifelse(gene_name %in% highlight_list,
                                paste(unlist(call.row$highlight), collapse = ';'), NA_character_),
    ) %>%
    separate_rows(Sample_Name, sep = '---') %>%
    # Need to ensure table contains reference so everything is properly facet_wrapped
    bind_rows(tibble(Sample_Name = factor(sample_headers, levels = sample_headers),
                     x_pos = NA_integer_, y_pos = NA_integer_))

  info_data <- gr_info %>%
    filter_by_overlaps(GRanges(seqnames = chr, strand = '*', ranges = IRanges(start = win_start, end = win_end))) %>%
    as_tibble() %>%
    mutate(x_pos = (end + start) / 2,
           y_pos = 0,
           Sample_Name = paste(sample_headers, collapse = '---'),
           color = case_when(
             section_name %in% high_impact_list ~ 'red',
             section_name %in% highlight_list ~ 'orange',
             band_staining == 'gpos100' ~ 'black',
             band_staining ==  'gpos50' ~ 'grey30',
             band_staining ==  'gpos25' ~ 'grey70',
             centromer ~ 'lightblue',
             TRUE ~ 'white'
           ),
           textcolor = ifelse(color %in% c('black', 'grey30'), 'white', 'black')
    ) %>%
    separate_rows(Sample_Name, sep = '---') %>%
    # Need to ensure table contains reference so everything is properly facet_wrapped
    bind_rows(tibble(Sample_Name = factor(sample_headers, levels = sample_headers),
                     x_pos = NA_integer_, y_pos = NA_integer_))

  panel_space_val <- unit(5, units = 'mm')

  cnv_track <- ggplot(calls) +
    geom_tile(aes(x = x_pos, y = y_pos, width = length, height = .9, fill = color)) +
    scale_fill_identity() +
    geom_text(aes(label = paste0(CNV_caller, ': ', CNV_type), x = x_pos, y = y_pos),
              vjust = 0.5, hjust = 0.5, size = 2.5) +
    scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','),
                       limits = c(win_start, win_end), oob = oob_keep) +
    scale_y_continuous(expand = expansion()) +
    facet_wrap(~Sample_Name, nrow = 1) +
    theme_classic() +
    theme(axis.title = element_blank(),
          axis.line = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          plot.background = element_blank(),
          panel.background = element_blank(),
          panel.border = element_blank(),
          strip.background = element_blank(),
          strip.text.x = element_blank(),
          panel.spacing = panel_space_val) +
    labs(y = 'Calls')

  gene_track <- ggplot(gene.data) +
    geom_tile(aes(x = x_pos, y = y_pos, width = width, height = .9,
                  fill = case_when(
                    !is.na(high_impact) ~ 'red',
                    direct_hit          ~ 'black',
                    TRUE                ~ 'grey50'
                  ),
        show.legend = F)
    ) +
    # Not readable most of the time
    # geom_text(aes(label = ID, x = x_pos, y = y_pos),
    # 		  vjust = 0.5, hjust = 0.5, size = 2.5) +
    scale_x_continuous(expand = expansion(), limits = c(win_start, win_end), oob = oob_keep) +
    scale_y_continuous(expand = expansion(add = c(0.25, 0.25))) +
    scale_fill_identity() +
    facet_wrap(~Sample_Name, nrow = 1) +
    theme_void() +
    theme(
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      axis.title.y = element_text(angle = 90, vjust = 1),
      panel.spacing = panel_space_val
    ) +
    labs(y = 'Genes')

  lrr <- ggplot(plot.data) +
    geom_rect(data = tibble(Sample_Name = sample_headers),
              aes(xmin = start, xmax = end, ymin = -1.5, ymax = 1.5), fill = 'grey50', alpha = 0.3) +
    geom_hline(yintercept = 0, col = 'grey10', linewidth=0.2) +
    geom_point(aes(x = Position, y = `Log R Ratio`,color = filter.passed),
               size = 0.5, shape = 20, show.legend = F) +
    scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) +
    theme_classic() +
    scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','),
                       limits = c(win_start, win_end), position = 'top') +
    scale_y_continuous(expand = expansion(), limits = c(-1.5, 1.5), oob = oob_squish) +
    labs(y = 'Log R Ratio', x = paste0('Position (', chr, ')')) +
    facet_wrap(~Sample_Name, nrow = 1) +
    theme(
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      panel.spacing = panel_space_val
    )

  baf <- ggplot(plot.data) +
    geom_hline(yintercept = 0, col = 'black', linewidth=0.5) +
    geom_hline(yintercept = 1, col = 'black', linewidth=0.5) +
    geom_rect(data = tibble(Sample_Name = sample_headers),
              aes(xmin = start, xmax = end, ymin = 0, ymax = 1), fill = 'grey50', alpha = 0.3) +
    geom_point(aes(x = Position, y = `B Allele Freq`,color = filter.passed),
               size = 0.5, shape = 20, show.legend = F) +
    scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) +
    theme_classic() +
    scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','), limits = c(win_start, win_end), oob = oob_keep) +
    scale_y_continuous(expand = expansion(), limits = c(-0.1, 1.1), oob = oob_squish, breaks = c(0, 0.5, 1)) +
    labs(y = 'B Allele Frequency', x = paste0('Position (', chr, ')')) +
    facet_wrap(~Sample_Name, nrow = 1) +
    theme(
      strip.background = element_blank(),
      strip.text.x = element_blank(),
      panel.spacing = panel_space_val
    )

  # # This still creates and empty plot area - not sure how to get rid of it
  # header <- ggplot(calls) + facet_wrap(~Sample_Name, nrow=1) + theme_classic() +
  #   theme(axis.line = element_blank(), plot.background = element_blank(),
  #         panel.background = element_blank(), panel.border = element_blank())
  header <- ggplot(info_data) + facet_wrap(~Sample_Name, nrow=1) + theme_classic() +
    geom_tile(aes(x = x_pos, y = y_pos, width = width, height = .9, fill = color),
              color = 'black', linewidth = 0.2) +
    scale_fill_identity() +
    geom_text(aes(label = section_name, x = x_pos, y = y_pos, color = textcolor),
              vjust = 0.5, hjust = 0.5, size = 2.5, show.legend = F) +
    scale_color_identity() +
    theme_classic() +
    scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','), limits = c(win_start, win_end), oob = oob_keep) +
    scale_y_continuous(expand = expansion()) +
    theme(axis.line = element_blank(),
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          axis.text = element_blank(),
          plot.background = element_blank(),
          panel.background = element_blank(),
          panel.border = element_blank(),
          panel.spacing = panel_space_val)

  n_cnvs <- length(na.omit(unique(calls$CNV_type)))
  gg <- header / cnv_track / lrr / baf / cnv_track / gene_track + plot_layout(heights = c(1, n_cnvs, 10, 10, n_cnvs, 2))

  calls <- calls %>%
    filter(!is.na(x_pos)) %>%
    dplyr::select(Sample_Name, 1, 3:4, reportable, reference_overlap, CNV_type, CNV_caller) %>%
    #dplyr::rename(Chr = seqnames) %>%
    arrange(Sample_Name, start) %>% #Chr
    rowwise() %>%
    mutate(across(c(CNV_type, CNV_caller), ~paste(., collapse = ',')))

  gene.data <- gene.data %>%
    filter(!is.na(x_pos)) %>%
    dplyr::select(seqnames, start, end, width, strand, high_impact, highlight, direct_hit, gene_name, gene_type, gene_id) %>%
    unique()

  list('gg' = gg, 'calls' = calls, 'genes' = gene.data)

}

reportable.calls <- cnv_calls %>%
    filter(tool.overlap.state != 'pre-overlap' &
                    sample_id == !!sample_id & reportable %in% c('critical', 'yes', 'yes, in ref.')) %>%
    dplyr::rename(Chr = seqnames, Size = length, Start = start, End = end) %>%
    mutate(reference_overlap = factor(reference_overlap),
           CNV_type = factor(CNV_type)) %>%
    arrange(reportable, Chr, Start)

non.reportable.calls <- cnv_calls %>%
    filter(tool.overlap.state != 'pre-overlap' &
                 sample_id == !!sample_id &	! reportable %in% c('critical', 'yes', 'yes, in ref.', NA)) %>%
    dplyr::rename(Chr = seqnames, Size = length, Start = start, End = end) %>%
    mutate(reference_overlap = factor(reference_overlap),
           CNV_type = factor(CNV_type)) %>%
    arrange(reportable, Chr, Start)

```

```{r reportable.header, eval = include.section('reportable.table') | include.section('reportable.plots'), results='asis'}

cat('## Reportable calls {.tabset}\n\n')

```

```{r reportable, results='asis', eval = include.section('reportable.table')}

cat('List of all reportable calls of the input samples. Overlapping calls from multiple tools with the same CNV.state (i.e. loss/gain) are merged.\n\n')
CNV_table_output(reportable.calls, caption = 'Critical and reportable calls')
# pdf: subchunkify?
#  subchunkify(simple_table_output(reportable.calls %>% dplyr::select(-(12:18)),
#                                   caption = 'Critical and reportable calls'),
#               'critical.call.table')
cat('\n\n')
```



```{r reportable.plots, eval = include.section('reportable.plots'), results='asis'}

if (nrow(reportable.calls)>0) {
  for (i in 1:nrow(reportable.calls)) {
    row <- reportable.calls[i,]

    state.str <- ifelse(row$reportable %in% c('critical', 'yes, in ref.', 'no, in ref.'),
                        paste0('(', str_remove(row$reportable, '(yes|no), '), ')'), '')
    cat(paste0('### ', row$CNV_type, ' ', state.str, ': ', row$Chr, ' - ', format_size(row$Size), '\n\n'))

    res <- make_LRR_BAF_plots(row,
                              report.setting('call.data.and.plots', 'plot.region.minsize.reportable'),
                              report.setting('call.data.and.plots', 'plot.flanking.region.relative'))
    if (typeof(res$gg) == 'character') {
      cat(res$gg, '\n\n')
      next()
    }

    if (report.setting('call.data.and.plots', 'include.plot')) {
      subchunkify(res$gg, paste0('plot.reportable.call.',i), 5, 10)
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.call.table')) {
      subchunkify(simple_table_output(res$calls), paste0('table.reportable.calls.',i))
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.gene.table.details') != 'None') {
      gene.tb <-  res$genes
      subchunkify(gene_table_output(gene.tb), paste0('table.reportable.genes.',i))
      cat('\n\n')
    }
    cat('\n\n')
  }
} else {
    cat('No reportable calls found')
}

cat('\n\n')
```

```{r nonreportable.header, eval = include.section('nonreportable.table') | include.section('nonreportable.plots'), results='asis'}

cat('## Non Reportable calls {.tabset}\n\n')

cat('This section includes all pre-processed calls (includes merging of tools and call filtering)\n\n')

```



```{r non.reportable,  eval = include.section('nonreportable.table'), results='asis', cache=FALSE}

CNV_table_output(non.reportable.calls, caption = 'Non reportable calls')
cat('\n\n')
```

```{r nonreportable.plots, eval = include.section('nonreportable.plots'), results='asis'}

if (nrow(non.reportable.calls)>0) {
  for (i in 1:nrow(non.reportable.calls)) {
    row <- non.reportable.calls[i,]
    state.str <- ifelse(row$reportable %in% c('critical', 'yes, in ref.', 'no, in ref.'),
                        paste0(' (', str_remove(row$reportable, '(yes|no), '), ')'), '')
    cat(paste0('### ', row$Chr, ' - ', format_size(row$Size), ': ', row$CNV_type, state.str, '\n\n'))

    res <- make_LRR_BAF_plots(row,
                              report.setting('call.data.and.plots', 'plot.region.minsize.nonreportable'),
                              report.setting('call.data.and.plots', 'plot.flanking.region.relative'))
    if (typeof(res$gg) == 'character') {
      cat(res$gg, '\n\n')
      next()
    }
    if (report.setting('call.data.and.plots', 'include.plot')) {
      subchunkify(res$gg, paste0('plot.nonreportable.call.',i), 5, 10)
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.call.table')) {
      subchunkify(simple_table_output(res$calls), paste0('table.nonreportable.calls.',i))
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.gene.table.details') != 'None') {
      gene.tb <-  res$genes
      if (report.setting('call.data.and.plots', 'include.gene.table.details') == 'Call') {
        gene.tb <- gene.tb %>%
          filter(direct_hit)
      }
      subchunkify(gene_table_output(gene.tb), paste0('table.nonreportable.genes.',i))
      cat('\n\n')
    }
    cat('\n\n')
  }
} else {
	cat('No non-reportable CNV calls present.')
}

cat('\n\n')
```


```{r plots.roi, eval=include_roi_plots, results='asis'}
cat('## Regions of Interest {.tabset}\n\n')

regions <- sampletable[sampletable$Sample_ID == sample_id, ]$Regions_of_Interest %>%
    str_split(';') %>% unlist()

use_chr_str <- all(str_detect(cnv_calls$Chr, 'chr'))
roundup_oom <- function(x) {10^(ceiling(log10(x)))}

# Using all here would swallow problems; the NA check should only be needed for empty entries
if (any(!is.na(regions)) & length(regions)>0) {
  for (region in regions) {

    region_name <- str_extract(region, '^[^|]+\\|') %>% str_remove('\\|')
    region_name <- ifelse(is.na(region_name), 'Region', region_name)

    Chr <- str_remove(region, '^[^|]+\\|') %>% str_remove(':.*') %>%
      str_remove(regex('chr', ignore_case = T))
    Chr <- ifelse(use_chr_str,  paste0('chr', Chr), Chr)
    Start <- str_extract(region, '(?<=:)[0-9]+') %>% as.numeric()
    End <- str_extract(region, '(?<=-)[0-9]+$') %>% as.numeric()
    Size <- End - Start

    size_order <- ifelse(log10(Size) >= 6, 1e6, 1e3)
    size_str <- ifelse(log10(Size) >= 6, 'Mb', 'kb')

    cat(paste0('### ', region_name, ', ', Chr, ': ', Start, ' - ', End, ' (', round(Size/size_order, 1), size_str ,')\n\n'))

    fake_tb <- tibble(Chr = Chr, Start = Start, End = End, Size = Size,
                      high.impact.genes = NA_character_, high.impact = list(NA_character_))
    res <- make_LRR_BAF_plots(fake_tb, roundup_oom(Size))
    if (typeof(res$gg) == 'character') {
      cat(res$gg, '\n\n')
      next()
    }

    if (report.setting('call.data.and.plots', 'include.plot')) {
      subchunkify(res$gg, paste0('plot.roi.', region_name, '-', Chr, '-', Start, '-', End), 5, 10)
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.call.table')) {
      subchunkify(simple_table_output(res$calls), paste0('table.roi.', region))
      cat('\n\n')
    }
    if (report.setting('call.data.and.plots', 'include.gene.table.details') != 'None') {
      gene.tb <-  res$genes
      if (report.setting('call.data.and.plots', 'include.gene.table.details') == 'Call') {
        gene.tb <- gene.tb %>%
          filter(direct_hit)
      }
      subchunkify(gene_table_output(gene.tb), paste0('table.roi.', region))
      cat('\n\n')
    }
  }
} else {
  cat('Nothing defined.')
}

cat('\n\n')
```

# Sample comparison  {.tabset}


```{r virtual.karyotype, eval = include.section('virtual.karyotype'), results='asis'}

cat('## Virtual Karyotype\n\n')

if (!is.na(ref_id)) {
  cat(str_glue('The first plot shows only this sample ({sample_name}), the second a side by side comparison  with the reference sample (left: {sample_name}; right: {ref_name}).\n\n'))
}

# Use prepared static data table (genome build specific, UCSC derived) instead of inbuilt RIdeogram
# data(human_karyotype, package="RIdeogram")
genome_data <- gr_info %>% filter(centromer) %>%
  group_by(size) %>%
  reduce_ranges() %>%
  as.data.frame() %>%
  dplyr::rename(Chr = seqnames, CE_start = start, CE_end = end, End = size) %>%
  mutate(Start = 0,
         Chr = str_remove(Chr, 'chr')) %>%
  select(Chr, Start, End, CE_start, CE_end)

sample.calls <- cnv_calls %>%
    dplyr::select(seqnames, start, end, CNV_type, sample_id) %>%
    dplyr::rename(Chr = seqnames, Start = start, End = end) %>%
    mutate(Value = ifelse(CNV_type %!in% c('gain', 'loss'), 0, 1),
           Value = ifelse(CNV_type == 'loss', -1, Value),
           Chr = str_remove(Chr, 'chr'))
overlay.tb <- sample.calls %>%
    filter(sample_id == !!sample_id) %>%
    dplyr::select(Chr, Start, End, Value)

#This should not be the case unless there are 0 calls that generated images
if (!dir.exists(file.path(workdir, image_folder))) {
    dir.create(file.path(workdir, image_folder))
}

svg_file1 <- tempfile(fileext = '.svg')
#somehow 'convertSVG' can't deal with absolute paths
png_file1 <- file.path(image_folder, 'chunk_ideogram_virtualKaryotype.png')

ideogram(genome_data, overlaid = overlay.tb, colorset1 = c('red', 'grey50', 'green'), output = svg_file1)
convertSVG(svg_file1, file = png_file1)

if (params$out_format == 'html') {
    cat(paste0('<img src="', png_file1, '" width="800" />'))
} else {
  #For reasons tiny-tex/latex executes from the directoy this template is located in (rather than the defined outdir), so relative paths don't work for pdf
  include_graphics(file.path(workdir, png_file1) %>% normalizePath, rel_path = FALSE)
}

if (!is.na(ref_id)) {
  refdata <- sample.calls %>%
        filter(sample_id == ref_id) %>%
        dplyr::select(Chr, Start, End, Value)

  svg_file2 <- tempfile(fileext = '.svg')
  png_file2 <- file.path(image_folder, 'chunk_ideogram_virtualKaryotype_vsRef.png')

  ideogram(genome_data, overlaid = overlay.tb, label = refdata, label_type = 'heatmap',
         colorset1 = c('red', 'grey50', 'green'), colorset2 = c('red', 'grey50', 'green'), output = svg_file2)
  convertSVG(svg_file2, file = png_file2)

  if (params$out_format == 'html') {
    cat(paste0('<img src="', png_file2, '" width="800" />'))
  } else {
    include_graphics(file.path(workdir, png_file2) %>% normalizePath, rel_path = FALSE)
  }
}

cat('\n\n')

```



<!-- ## Circo / Circular plots -->

<!-- Not added yet -->

<!-- ```{python gosling.plots} -->
<!-- import gosling as gos -->
<!-- ``` -->


```{r snp.dendrogram, results='asis', eval = include.section('SNP.dendrogram')}

cat('## SNP dendrogram\n\n')

#Build annotation table
color_by <- report.setting('SNP_comparison', 'dendrogram.color.by') #%>% check_cols_exits()
shape_by <- report.setting('SNP_comparison', 'dendrogram.shape.by') #%>% check_cols_exits()
dend.format.df <- sampletable %>%
    filter(Sample_ID %in% snp.ids)

if (length(color_by) == 1) {

    if (nrow(unique(dend.format.df[, color_by])) > 10) {
        warn_str <- str_glue('More than 10 colors are needed to use "{color_by}" for coloring. Consider using fewer unqiue entries.')
        cat(warn_str, '\n\n')
        warning(warn_str)
    }

    dend.format.df <- dend.format.df %>%
        mutate(across(all_of(color_by), ~ factor(., levels = sort(unique(.))))	) %>%
        arrange(!!sym(color_by)) %>%
        mutate(col = viridis_pal(option='H')(length(unique(!!sym(color_by))))[match(!!sym(color_by), unique(!!sym(color_by)))],
                     col = ifelse(is.na(!!sym(color_by)), 'grey90', col)
                     )

    col_map <- dend.format.df$col %>% unique()
    names(col_map) <- levels(pull(dend.format.df, !!sym(color_by)))


} else {
    warning('No matching column to use for coloring!')
    cat('No matching column to use for coloring!\n')

    dend.format.df <- dend.format.df %>%
        mutate(col = 'black', `_dummy_color` = 'bar')

    col_map  <- c('bar' = 'black')
    color_by <- '_dummy_color'
}

if (length(shape_by) == 1) {

    dend.format.df <- dend.format.df %>%
        mutate(across(all_of(shape_by), ~ factor(., levels = sort(unique(.), na.last = T))),
                     ) %>%
        arrange(!!sym(shape_by))

    if (nrow(na.omit(unique(dend.format.df[, shape_by]))) <= 5) {
        use.shapes <- 15:18
        na.shape <- 1
    } else if (nrow(na.omit(unique(dend.format.df[, shape_by]))) <= 15) {
        use.shapes <- 0:14
        na.shape <- 16
    } else {
        others <- dend.format.df[pull(dend.format.df, !!sym(shape_by)) %>% as.integer() > 15, shape_by] %>% na.omit() %>% unlist()
        warn_str <- str_glue('Only 15 shapes are available, but "{shape_by}" would need {length(unique(pull(dend.format.df, !!sym(shape_by))))}. ',
							 'Consider using fewer unqiue entries. These values are summarised as "Other": {paste(others, collapse = ", ")}')
        cat(warn_str, '\n\n')
        warning(warn_str)

        use.shapes <- 0:14
        na.shape <- 16

        dend.format.df <- dend.format.df %>%
            mutate(across(all_of(shape_by), ~ ifelse(as.integer(.) > 15, 'Other', as.character(.))),
                         across(all_of(shape_by), ~ factor(., levels = unique(.))) )
    }

    dend.format.df <- dend.format.df %>%
        mutate(shape = use.shapes[match(!!sym(shape_by), unique(!!sym(shape_by)))],
                     shape = ifelse(is.na(!!sym(shape_by)), na.shape, shape)
                     )

    shape_map <- dend.format.df$shape %>% unique()
    names(shape_map) <- levels(pull(dend.format.df, !!sym(shape_by)))


} else {
    warning('No matching column to use for shapes!')
    cat('No matching column to use for shapes!\n\n')

    dend.format.df <- dend.format.df %>%
        mutate(shape = 16, `_dummy_shape` = 'foo')

    shape_map <- c('foo' = 16)
    shape_by <- '_dummy_shape'

}

# Build dendrogram & sort annotation table by it
hc <- hclust(SNP.genotype.distances)
dd <- as.dendrogram(hc) 
dend.format.df <- dend.format.df[match(labels(dd), dend.format.df$Sample_ID),]

dend <- dd %>%
  set('labels_col', dend.format.df$col) %>%
  set('leaves_col', dend.format.df$col) %>%
  set('leaves_pch', dend.format.df$shape) 

gg1 <- dend %>%
  raise.dendrogram (max(SNP.genotype.distances)/50) %>% 
  set('labels_cex', .8) %>%
  set('leaves_cex', 2) %>%
  set('branches_lwd', .5) %>%
  as.ggdend() %>%
  ggplot(offset_labels = -max(SNP.genotype.distances)/25,
             theme = theme_classic()) +
    scale_y_continuous(name = 'SNP distance (manhattan method)',
                                         breaks = function(limits) breaks_pretty()(c(max(limits[1], 0), limits[2]), 5) + max(SNP.genotype.distances)/50,
                                         labels = function(breaks) number(breaks - max(SNP.genotype.distances)/50, big.mark = ','),
                                         limits = c(-max(SNP.genotype.distances)/2, NA),
                                         expand = expansion()) +
    scale_x_continuous(limits = c(0, NA), expand = expansion(add = c(0, .5))) +
    geom_line(data = tibble(x = c(0, 0), y = max(SNP.genotype.distances) * c(1/50, 51/50)),
                        aes(x=x, y=y)) +
  theme(legend.position = "bottom",
            axis.text.x = element_blank(),
            axis.title.x = element_blank(),
            axis.line.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.line.y = element_blank(),
            axis.title.y = element_text(angle = 90, hjust = .75)
            )

# make legend
gg2 <- dend.format.df %>%
  #arrange(SampleGroup) %>%
  ggplot(aes(x = Sample_ID, y = 1, col = !!sym(color_by), shape = !!sym(shape_by))) +
  geom_point() + 
  scale_color_manual(values = col_map, guide = ifelse(color_by == '_dummy_color', list('none'),
                                        list(guide_legend(direction = 'horizontal',title.position = 'top', ncol = 8, byrow=T)))[[1]] )  +
  scale_shape_manual(values = shape_map, guide = ifelse(shape_by == '_dummy_shape', list('none'),
                                  list(guide_legend(direction = 'horizontal',title.position = 'top', ncol = 8, byrow=T)))[[1]] ) +
  theme(legend.box = "vertical", legend.text = element_text(size = 10), legend.title = element_text(size = 12))

gg <- gg1 + as_ggplot(get_legend(gg2)) + plot_layout(ncol = 1, heights = c(
  5, 1))

subchunkify(gg, 'snp.dendrogram', 8, 10)

```







