---
title: "CNV report"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
params:
  base_path: '/home/vonkunic_c/Misc-Projects/CNV-pipeline' #tests
  sample_id: '206819830066_R12C02'  #'GSM2538923_9371579017'
  #Don't pull from here? pull from sampletable instead -> easier to test report
  #reference_id: '204362030005_R07C01'
  sampletable: 'sample_table.txt' #'sample_table.txt'
  configfile: 'config.yaml' #'CytoSNP-config.yaml'
  workdir: '/home/vonkunic_c/Misc-Projects/CNV-pipeline/tests/data/GSM2538923_9371579017'
---

<style type="text/css">
.main-container {
  max-width: 100% !important;
  margin: auto;
}
</style>


```{r setup, include=FALSE}
#setwd(file.path(params$base_path, "data", params$sample_id))
#library(plyranges)
#library(GenomicRanges)
# -> probably will need it again for plotting of gene tracks
library(tidyverse)
#library(dendextend)
library(ggpubr)
library(scales)
#library(RIdeogram)
#library(DT)
library(yaml)
library(patchwork)

basepath <- params$base_path
workdir <- ifelse(params$workdir == '', getwd(), params$workdir)
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE, #cache=FALSE, 
                      fig.path = file.path(workdir, 'report_images/')#,
											#dev = "cairo_pdf"
											)


config <- read_yaml(file.path(basepath, params$configfile))
use.filter <- config$settings$filter$`use-filterset`

sampletable <- read_tsv(file.path(basepath, params$sampletable), col_types = 'cccccc') 

sample_id <- params$sample_id
sample_name <- sampletable[sampletable$Sample_ID == sample_id, ]$SampleName
sex <- sampletable[sampletable$Sample_ID == sample_id, ]$Sex %>%
	tolower() %>% substr(1,1)

ref_name <- sampletable[sampletable$Sample_ID == sample_id, ]$ReferenceSample
ref_id <- ifelse(is.na(ref_name), NA, sampletable[sampletable$SampleName == ref_name, ]$Sample_ID)

use_ids <- c(sample_id )
if (!is.na(ref_id)){ 
  use_ids <- c(sample_id, ref_id)
  sex.ref <- sampletable[sampletable$Sample_ID == ref_id, ]$Sex %>%
  	tolower() %>% substr(1,1)
  
  if(sex.ref != sex) {
  	stop('Sex of sample and reference does not match!')
  } 
  
}

# Report only reads the actual config file, not the default one, so we need default values here as well
config_val <- function(value, section, default=NULL) {
	val=config$settings$report[[section]][[value]]
	if (is.null(val)) {
		return(default)
	} else {
		return(val)
	}
}

#Reportable thresholds
reportable.loh = config_val('min.snp', 'thresholds', 2.5e6)
reportable.cnv = config_val('min.snp', 'thresholds', 4e5)
fail.loh = config_val('min.snp', 'thresholds', 5e6)
fail.cnv = config_val('min.snp', 'thresholds', 2e6)

#Warning tresholds
callrate_warnings = config_val('callrate', 'QCwarnings', c(0.99, 0.99))
total_CNV_warnings = config_val('total_CNV', 'QCwarnings', c(10, 50))
total_LOH_warnings = config_val('total_LOH', 'QCwarnings', c(30, 75))
ratio_CNV_warnings = config_val('ratio_CNV', 'QCwarnings', c(2, 4))
sizable_CNV_warnings = config_val('sizable_CNV', 'QCwarnings', c(5, 10))
sizable_LOH_warnings = config_val('sizable_LOH', 'QCwarnings', c(5, 10))

# Misc #
subchunkify <- function(g, id, fig_height=7, fig_width=7, options = '') {
  g_deparsed <- paste0(deparse(function() {g}), collapse = '')

  sub_chunk <- paste0("```{r sub_chunk_", id, ", fig.height=", fig_height, ", fig.width=", fig_width, 
                      ifelse(options == '', options, paste(',', options)), ", echo=FALSE}\n",
  "(",  g_deparsed, ")()",
  "\n```")

  cat(knitr::knit(text = knitr::knit_expand(text = sub_chunk), quiet = TRUE))
}

```

```{r read.data}

# Read Data

## Raw (BAF / LRR)
valid_name=config$wildcard_constraints$sample_id
valid_name=ifelse(is.null(valid_name), '[0-9]{12}_R[0-9]{2}C[0-9]{2}', valid_name)
if (!all(str_detect(use_ids, valid_name))) {stop('Sample id does not match supplied or default wildcard constraints!')}

read_raw <- function(filename) {
	read_tsv(filename, show_col_types = FALSE) %>%
				rename_with(~ str_remove(., '.*\\.')) %>%
		dplyr::select(-any_of(c('Index', 'Address', 'Name', 'R', 'Theta')),
									-contains('Frac'), -contains('X'), -contains('Y')) %>%
		mutate(sample_id = str_extract(filename, valid_name),
			   Chr = paste0('chr', Chr))
}

filter_functions = list(
	'basic'   = function(GT, GC) GT > 0.15,
	'highGT'   = function(GT, GC) GT > 0.8,
	'highGC'   = function(GT, GC) GT > 0.15 & GC > 0.8,
	'full' = function(GT, GC) GT > 0.8 & GC > 0.8,
	'highGT+GC' = function(GT, GC) GT > 0.8 & GC > 0.8
)

raw_LRR_BAF <- file.path(basepath, 'data', use_ids, paste0(use_ids, '.processed-data.tsv')) %>%
  lapply(read_raw) %>%
	bind_rows() %>%
	mutate(filter.passed = filter_functions[[config$settings$filter$`use-filterset`]](`GenTrain Score`, Score))

## CNV calls

load_annotate_cnv <- function(fname){
	readRDS(fname) %>%
		rowwise() %>%
		mutate(
			main.state = CNV.state[[1]],
			call.in.reference = ifelse(is.na(call.in.reference), F, call.in.reference),
			reportable = case_when(
				tool.overlap.state == 'pre-overlap'                                ~ NA_character_,
				main.state == 'LOH' & length >= reportable.loh & call.in.reference ~ 'yes, in ref.',
				main.state != 'LOH' & length >= reportable.cnv & call.in.reference ~ 'yes, in ref.',
				main.state == 'LOH' & length >= fail.loh                           ~ 'critical',
				main.state != 'LOH' & length >= fail.cnv                           ~ 'critical',
				main.state == 'LOH' & length >= reportable.loh                     ~ 'yes',
				main.state != 'LOH' & length >= reportable.cnv                     ~ 'yes',
				call.in.reference                                                 ~ 'no, in ref.',
				TRUE                                                              ~ 'no') %>%
				factor(levels = c('critical', 'yes', 'yes, in ref.', 'no', 'no, in ref.'))
		)
}

cnv_calls <- lapply(file.path(basepath, 'data', use_ids, paste0(use_ids, '.combined-cnv-calls.', use.filter, '.rds')), load_annotate_cnv) %>%
	bind_rows()

## GenCall logs
GenCall.stats <-  file.path(basepath, 'data', use_ids, paste0(use_ids, '.stats.txt')) %>%
	lapply(read_tsv, show_col_types = FALSE, col_types = cols(computed_gender = col_character(),
	                                                          sentrix_barcode = col_character())) %>%
	bind_rows() %>%
	dplyr::select(-(5:7)) %>%
	mutate(gtc = str_remove(gtc, '.gencall.gtc')) %>%
	dplyr::rename(sample_id = gtc)

## PennCNV logs & stats

#TODO
# -> could be exported by the preprocess script? (better than loading & summarizing here at least ...)

## CBS logs & stats

#TODO

```


# Sample Overview

## QC metrics {.tabset}

```{r qc.metrics}

if (!is.na(ref_id)) {
  sample_headers <- c(sample_name, paste0('Reference (', ref_name, ')'))
  names(sample_headers) <- c(sample_id, ref_id)
} else {
  sample_headers <- c(sample_name )
  names(sample_headers) <- c(sample_id )
}

tr_tibble <- function(tb) {
	tr <- t(tb )
	colnames(tr) <- sample_headers[tr[1,]]
	tb <- as.data.frame(tr) %>% rownames_to_column(var = ' ')
	tb[2:nrow(tb),]
}

apply_warnings <- function(tb, ...){
	
	
}

metrics <- list(
	GenCall.stats %>%
		dplyr::select(sample_id, call_rate, computed_gender) %>%
		mutate(call_rate = round(call_rate, 3)),
	raw_LRR_BAF %>%
		group_by(sample_id) %>%
		#TODO: if different chips are used that will be an issue. Should be catched earlier somehow
		summarise(SNPs_post_filter = (100 * sum(filter.passed, na.rm=T) / unique(GenCall.stats$number_snps) ) %>%
																		format(digits = 2, nsmall=2) %>% paste('%')),
	cnv_calls %>%
		#don't do individual tools here -> move to per tool section!
		filter(tool.overlap.state != 'pre-overlap') %>%
		group_by(sample_id) %>%
		mutate(class = factor(ifelse(main.state == 'LOH', 'LOH', 'CNV'), levels = c('CNV', 'LOH')),
					 loss.gain_log2ratio = log2(sum(main.state == 'gain') / sum(main.state == 'loss')) %>% round(digits = 2),
					 loss.gain_log2ratio = ifelse(is.infinite(loss.gain_log2ratio) | is.nan(loss.gain_log2ratio), NA, loss.gain_log2ratio)
		) %>%
		group_by(sample_id, loss.gain_log2ratio, class, .drop = F) %>%
		summarise(total_calls = n(),
							reportable_new_calls = sum(str_detect(reportable, 'critical|yes$')),
							critical_new_calls = sum(reportable == 'critical'),
							) %>%
		pivot_wider(names_from = class, values_from = contains('calls')) 
)

apply_gr_th <- function(data, warning_levels){
	case_when(
		data > warning_levels[[2]] ~ 'orange',
		data > warning_levels[[1]] ~ 'yellow',
		TRUE                       ~ 'green',
	)
}

metric.colors <- list(
	mutate(metrics[[1]],
				 call_rate = case_when(
				 	call_rate < callrate_warnings[[2]]  ~ 'red',
					call_rate < callrate_warnings[[1]]  ~ 'yellow',
					TRUE ~ 'green'),
				 computed_gender = ifelse(tolower(computed_gender) != sex, 'red', 'green')),
	mutate(metrics[[2]],
				 SNPs_post_filter = 'white'),
	mutate(metrics[[3]], 
				 loss.gain_log2ratio = apply_gr_th(abs(loss.gain_log2ratio), ratio_CNV_warnings),
				 total_calls_CNV = apply_gr_th(total_calls_CNV, total_CNV_warnings),
				 total_calls_LOH = apply_gr_th(total_calls_LOH, total_LOH_warnings),
				 reportable_new_calls_CNV = apply_gr_th(reportable_new_calls_CNV, sizable_CNV_warnings),
				 reportable_new_calls_LOH = apply_gr_th(reportable_new_calls_LOH, sizable_LOH_warnings),
				 critical_new_calls_CNV = ifelse(critical_new_calls_CNV >= 1, 'red', 'green'),
				 critical_new_calls_LOH = ifelse(critical_new_calls_LOH >= 1, 'red', 'green'),
				)
		)

Combined.metrics <- lapply(metrics, tr_tibble) %>% bind_rows()
Combined.colors <-  lapply(metric.colors, tr_tibble) %>% bind_rows()

```

### Summary

```{r qc.summary, echo=FALSE}
datatable(Combined.metrics, options = list(dom = 't', pageLength = nrow(Combined.metrics)),
          rownames = FALSE) %>%
	formatStyle(2, backgroundColor = styleRow(1:nrow(Combined.metrics), Combined.colors[, sample_headers[[1]]]), textAlign = 'center') %>%
	# DT can take specification of non-existing columns - just need a workaround for the sample_header call
	formatStyle(3, backgroundColor = styleRow(1:nrow(Combined.metrics), Combined.colors[, sample_headers[[length(sample_headers)]]]), textAlign = 'center')
```


### GenCall

```{r qc.gencall, echo=FALSE}
datatable(GenCall.stats %>% tr_tibble(), options = list(dom = 't', pageLength = ncol(GenCall.stats)), rownames = FALSE)
```

### PennCNV

TODO: what can be extracted from log files

### CBS

TODO: what can be extracted from log files

### Pipeline settings

make a table with all settings used for the analysis (from snakemake config, patch with defaults?)

?? put the R version/package info output here ?

<!-- ## Recommended action: -->

<!-- .Pass/Fail/Check recommendation (Steps: Data QC, CNV calling) -->

<!-- TODO (how?): Sample similarity) -->

<!-- ```{r recommendation} -->


<!-- ``` -->

# CNV calling

## Reportable calls {.tabset}

List of all reportable calls (summarised over all input samples and tools used).

```{r reportable}

# TODO - DT defaults
# - format number 000.000.000
# - hide/remove strand
# - hide/remove merge events
# - move selector down; move search bar?

reportable.calls <- cnv_calls %>% 
	filter(sample_id == !!sample_id & reportable %in% c('critical', 'yes', 'yes, in ref.')) %>%
	dplyr::rename(Chr = seqnames, Size = length, Start = start, End = end) %>%
	dplyr::select(1:5, reportable, main.state, 6:17) %>%
	mutate(call.in.reference = factor(call.in.reference),
				 main.state = factor(main.state)) %>%
	arrange(reportable, Chr, Start)

datatable(reportable.calls, caption = 'Critical & reportable calls',
		  rownames = F,
		  extensions = c('Buttons', 'Scroller'),
		  filter = 'top',
		  options = list(
		  	scrollY = 300, scrollCollapse = TRUE,
        scrollX =  TRUE,
        scroller = TRUE,
        dom = 'Bftilp', #TODO -> change this
		  	buttons = c('colvis', 'copy', 'csv', 'excel'),
				columnDefs = list(
		  		list(targets = c(0,10:18), visible = FALSE)
		  	)
			)
		) %>%
	formatRound(c('Start', 'End', 'Size'), digits = 0, mark = '.')

```

```{r plot.functions}

# TODO
# Add coloring by weight / GenCall score ?
# -> wouldn't work for PennCNV?

color_map <- c(
	 `1.45` = '#1a9850', #PennCNV gain
	 `1.35` = '#66bd63', #CBS gain
	`-1.35` = '#d73027', #PennCNV loss
	`-1.45` = '#f46d43'  #PennCNV loss
)

make_LRR_BAF_plots <- function(chr, start, end, size=1e6) {
	# chr, start, end, samples = row %>% unpack()
	
	#minimum 1Mb to each side of the merged call
	size = max(size, 1e6)
	#Max size of Chr covered by probes
	chr_max = raw_LRR_BAF %>% filter(Chr == chr) %>% pull(Position) %>% max()
	win_start = max(start -size, 0)
	win_end = min(end + size, chr_max)
	
	# get raw LRR & BAF data; mark filtered points
	plot.data <- raw_LRR_BAF %>%
		filter(Chr == chr & Position >= win_start & Position <= win_end) %>%
		mutate(SampleName = factor(sapply(sample_id, function(x) sample_headers[x]), levels = sample_headers))
			   
	calls <- cnv_calls %>%
		filter(tool.overlap.state != 'post-overlap' & seqnames == chr & end >= win_start & start < win_end) %>%
		mutate(x_pos = (end + start) / 2, 
			   y_pos = ifelse(main.state == 'gain', 1.4, -1.4) + ifelse(str_detect(tool, 'PennCNV'), 0.05, -0.05),
			   y_pos_baf = ifelse(main.state == 'gain', 1.025, -0.075) + ifelse(str_detect(tool, 'PennCNV'), 0.05, 0),
			   color = color_map[as.character(y_pos)],
			   color = ifelse(main.state == 'LOH', 'grey50', color),
			   col_label = paste(tool, main.state),
				 SampleName = factor(sapply(sample_id, function(x) sample_headers[x]), levels = sample_headers)
			   )
		
	#message('..plot data loaded')
	#write("..plot data loaded", stderr())
	
	# Make the plots
	lrr <- 	ggplot(plot.data) + 
		geom_hline(yintercept = 0, col = 'grey10', linewidth=0.2) + 
		geom_tile(data = calls, aes(x = x_pos, y = y_pos, width = length, height = 0.1, fill = color)) + 
		scale_fill_identity() + 
		geom_point(aes(x = Position, y = `Log R Ratio`,color = filter.passed),
				   size = 0.5, shape = 20, show.legend = F) + 
		scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) + 
		geom_text(data = calls, aes(label = paste0(tool, ': ', CNV.state), x = x_pos, y = y_pos),
				  vjust = 0.5, hjust = 0.5, size = 2.5) +
		theme_classic() +
		scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','), limits = c(win_start, win_end), oob = oob_keep) +
		scale_y_continuous(expand = expansion(), limits = c(-1.5, 1.5), oob = oob_squish) +
		labs(y = 'Log R Ratio', x = paste0('Position (', chr, ')')) + 
		facet_wrap(~SampleName, nrow = 1)
	
	#message('..lrr done')
	#write("..lrr done", stderr())
	
	baf <- 	ggplot(plot.data) + 
		geom_hline(yintercept = 0, col = 'black', linewidth=0.5) + 
		geom_hline(yintercept = 1, col = 'black', linewidth=0.5) + 
		geom_tile(data = calls, aes(x = x_pos, y = y_pos_baf, width = length, height = 0.05, fill = color)) + 
		scale_fill_identity() + 
		geom_point(aes(x = Position, y = `B Allele Freq`,color = filter.passed),
				   size = 0.5, shape = 20, show.legend = F) + 
		scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) + 
		geom_text(data = calls, aes(label = paste0(tool, ': ', CNV.state), x = x_pos, y = y_pos_baf), 
				  vjust = 0.5, hjust = 0.5, size = 2.5) + 
		theme_classic() + 
		scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ','), limits = c(win_start, win_end), oob = oob_keep) + 
		scale_y_continuous(expand = expansion(), limits = c(-0.1, 1.1), oob = oob_squish, breaks = c(0, 0.5, 1)) + 
		labs(y = 'B Allele Frequency', x = paste0('Position (', chr, ')')) + 
		facet_wrap(~SampleName, nrow = 1)
	
	#message('..baf done')
	#write("..baf done", stderr())
	
	# this crashes somehow?
	# --> first point where image ggplot image is calculated
	#gg <- ggarrange(lrr, baf, nrow = 1, common.legend = T, legend = 'bottom')
	gg <- lrr / baf
	
	#message('..ggarange done')
	#write("..ggarange done", stderr())
	
	calls <- calls %>% dplyr::select(SampleName, 1:4, reportable, call.in.reference, CNV.state, tool) %>%
		dplyr::rename(Chr = seqnames) %>%
		arrange(SampleName, Chr, start) %>%
		rowwise() %>%
		mutate(across(c(CNV.state, tool), ~paste(., collapse = ',')))

	list('gg' = gg, 'calls' = calls)
	
}

# library(plotly)
# library(crosstalk)

make_LRR_BAF_plotly <- function() {
	# chr, start, end, samples = row %>% unpack()
	
	#default size
	window.szie = 2.5e6

		
	#Include *all* individual calls (but merged per tool/sample)
	
	# TODO - redo this
	#  - plot data should contain full sample/`GR.all` derived table
	# 		-> ref.data maybe only on hover? or per toggle?
	#			or: ref data in a second facet ?
	#  - accompanying DT should contain ? reportable ... ? calls only, flagged by in.ref yes/no
	# -> need to use a sharedData element, which can only contain a single table
	# (crosstalk package)
	
	
	calls <- cnv_calls %>%
		filter(tool.overlap.state != 'post-overlap') %>%
		mutate(x_pos = (end + start) / 2, 
			   y_pos = ifelse(main.state == 'gain', 1.4, -1.4) + ifelse(str_detect(tools, 'PennCNV'), 0.05, -0.05),
			   y_pos_baf = ifelse(main.state == 'gain', 1.025, -0.075) + ifelse(str_detect(tools, 'PennCNV'), 0.05, 0),
			   color = color_map[as.character(y_pos)],
			   color = ifelse(main.state == 'LOH', 'grey50', color),
			   col_label = paste(tools, main.state),
			   )
	# -> some way to use calls 
	
	sharedCalls <- crosstalk::SharedData$new(calls)

	# Make the plots
	lrr <- 	ggplot(sharedCalls) + 
		geom_hline(yintercept = 0, col = 'grey10', linewidth=0.2) + 
		geom_tile(aes(x = x_pos, y = y_pos, width = size, height = 0.1, fill = color)) + 
		scale_fill_identity() + 
		geom_point(data = raw_LRR_BAF, aes(x = Position, y = `Log R Ratio`,color = filter.passed),
				   size = 0.5, shape = 20, show.legend = F) + 
		scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) + 
		geom_text(aes(label = paste0(tools, ': ', CNV.state), x = x_pos, y = y_pos),
				  vjust = 0.5, hjust = 0.5, size = 2.5) +
		theme_classic() +
		scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ',')) +
		scale_y_continuous(expand = expansion(), limits = c(-1.5, 1.5), oob = oob_squish) +
		labs(y = 'Log R Ratio', x = paste0('Position')) 
	lrr <- ggplotly(lrr)
	
	baf <- 	ggplot(plot.data) + 
		geom_hline(yintercept = 0, col = 'black', linewidth=0.5) + 
		geom_hline(yintercept = 1, col = 'black', linewidth=0.5) + 
		geom_tile(data = calls, aes(x = x_pos, y = y_pos_baf, width = size, height = 0.05, fill = color)) + 
		scale_fill_identity() + 
		geom_point(aes(x = Position, y = `B Allele Freq`,color = filter.passed),
				   size = 0.5, shape = 20, show.legend = F) + 
		scale_color_manual(values=c('TRUE' = 'blue', 'FALSE' = 'grey70')) + 
		geom_text(data = calls, aes(label = paste0(tool, ': ', CNV.state), x = x_pos, y = y_pos_baf), 
				  vjust = 0.5, hjust = 0.5, size = 2.5) + 
		theme_classic() + 
		scale_x_continuous(expand = expansion(), labels = label_number(big.mark = '.', decimal.mark = ',')) + 
		scale_y_continuous(expand = expansion(), limits = c(-0.1, 1.1), oob = oob_squish, breaks = c(0, 0.5, 1)) + 
		labs(y = 'B Allele Frequency', x = paste0('Position (', chr, ')'))

	# this crashes somehow?
	# --> first point where image ggplot image is calculated
	gg <- ggarrange(lrr, baf, nrow = 1, common.legend = T, legend = 'bottom')
	
	calls <- calls %>% dplyr::select(-strand, -x_pos, -y_pos, -y_pos_baf, -color, -col_label)

	list('gg' = gg, 'calls' = calls)
	
}


```

```{r indiv.plots, results='asis'}

# initialize ggplot somehow?
dummy <- ggplot(reportable.calls) +
	geom_bar(aes(y = mean_no_snps))

write("starting plots", stderr())

if (nrow(reportable.calls)>0) {
	for (i in 1:nrow(reportable.calls)) {
		
		row = reportable.calls[i,]
		
		cat(paste0('### ', row$main.state, ' (', row$reportable, '): ', row$Chr, ' - ', round(row$Size/1e6, 1), 'Mb\n\n'))
		
		res <- make_LRR_BAF_plots(row$Chr, row$Start, row$End, row$Size)
		subchunkify(res$gg, paste0('plot.reportable.call.',i), 5, 10)
		
		subchunkify(res$call, paste0('table.reportable.call.',i))
		message(paste("plot", i , "done"))
		
		cat('\n\n')
		
	}
} else {
	cat('No reportable calls found')
}

```

## Non Reportable calls {.tabset}

Second (less strict filter set for CNV calls)
but not everything! 
i.e. numsnp > 5 & length > 100 & (numsnp > 10 | length > 2000)


```{r non.reportable, results='asis', cache=FALSE}

non.reportable.calls <- cnv_calls %>% 
	filter(sample_id == !!sample_id &	! reportable %in% c('critical', 'yes', 'yes, in ref.', NA)) %>%
	dplyr::rename(Chr = seqnames, Size = length, Start = start, End = end) %>%
	dplyr::select(1:5, reportable, main.state, 6:17) %>%
	mutate(call.in.reference = factor(call.in.reference),
				 main.state = factor(main.state)) %>%
	arrange(reportable, Chr, Start)

datatable(non.reportable.calls, caption = 'Non reportable calls',
		  rownames = F,
		  extensions = c('Buttons', 'Scroller'),
		  filter = 'top',
		  options = list(
		  	scrollY = 300, scrollCollapse = TRUE,
	      scrollX =  TRUE,
	      scroller = TRUE,
	      dom = 'Bftilp', #TODO -> change this
		  	buttons = c('colvis', 'copy', 'csv', 'excel'),
				columnDefs = list(
		  		list(targets = c(0,10:18), visible = FALSE)
		  	)
			)
		) %>%
	formatRound(c('Start', 'End', 'Size'), digits = 0, mark = '.')

if (nrow(non.reportable.calls)>0) {
	for (i in 1:nrow(non.reportable.calls)) {
		
		row = non.reportable.calls[i,]
		
		cat(paste0('### ', row$Chr, ' - ', round(row$size/1e3, 1), 'kb: ', row$main.state, ' (', row$reportable, ')\n\n'))
	
		res <- make_LRR_BAF_plots(row$Chr, row$Start, row$End, row$Size)
		subchunkify(res$gg, paste0('plot.nonreportable.call.',i), 5, 10)
		
		subchunkify(res$call, paste0('table.nonreportable.call.',i))
		
		cat('\n\n')
		
	}
} 
# else {
# 	cat('No CNV calls present.')
# }


```


## Virtual Karyotype {.tabset}

Virtual Karyotype for each sample.

Direct comparison to the first reference sample () is shown side by side (left: sample; right: reference).

```{r rideogram, results='asis'}
# TODO: need to get the proper data from somewhere else, fasta maybe?
# -> needs to contain centromer positions as well

# This os supposedly GRCh38
data(human_karyotype, package="RIdeogram")

sample.calls <- cnv_calls %>%
	dplyr::select(seqnames, start, end, main.state, sample_id) %>%
	dplyr::rename(Chr = seqnames, Start = start, End = end) %>%
	mutate(Value = ifelse(main.state == 'LOH', 0, 1),
		   Value = ifelse(main.state == 'loss', -1, Value),
		   Chr = str_remove(Chr, 'chr'))
overlay.tb <- sample.calls %>%
	filter(sample_id == !!sample_id) %>%
	dplyr::select(Chr, Start, End, Value)

#TODO: output needs to be checked
svg_file1 = tempfile(fileext = '.svg')
#somehow 'convertSVG' can't deal with absolute paths
png_file1 = file.path('report_images', 'chunk_ideogram_virtualKaryotype.png')

ideogram(human_karyotype, overlaid = overlay.tb, colorset1 = c('red', 'grey50', 'green'), output = svg_file1)
convertSVG(svg_file1, file = png_file1)

cat(paste0('<img src="', png_file1, '" width="800" />'))

if (!is.na(ref_id)) {
  refdata <- sample.calls %>%
		filter(sample_id == ref_id) %>%
		dplyr::select(Chr, Start, End, Value)

  svg_file2 = tempfile(fileext = '.svg')
  png_file2 = file.path('report_images', 'chunk_ideogram_virtualKaryotype_vsRef.png')

  ideogram(human_karyotype, overlaid = overlay.tb, label = refdata, label_type = 'heatmap',
  		 colorset1 = c('red', 'grey50', 'green'), colorset2 = c('red', 'grey50', 'green'), output = svg_file2)
  convertSVG(svg_file2, file = png_file2)

  cat(paste0('<img src="', png_file2, '" width="800" />'))
}

```




# Sample comparison

## CNV level

- side by side plot over all chromosomes here ?

## SNP level


- dendrogram


# R sessioninfo

```{r sessioninfo}
sessionInfo()
```
